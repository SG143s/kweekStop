"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _async_to_generator = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"./node_modules/@swc/helpers/esm/_async_to_generator.js\");\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"./node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"./node_modules/@swc/helpers/esm/_create_class.js\");\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"./node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _ts_generator = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"./node_modules/@swc/helpers/esm/_ts_generator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default() {\n        return Router;\n    },\n    matchesMiddleware: function matchesMiddleware1() {\n        return matchesMiddleware;\n    },\n    createKey: function createKey1() {\n        return createKey;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nvar _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _resolverewrites = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nvar _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator._(function(options) {\n        var matchers, _ref, asPathname, cleanedAs, asWithBasePathAndLocale;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        Promise.resolve(options.router.pageLoader.getMiddleware())\n                    ];\n                case 1:\n                    matchers = _state.sent();\n                    if (!matchers) return [\n                        2,\n                        false\n                    ];\n                    _ref = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref.pathname;\n                    cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n                    asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n                    // Check only path match on client. Matching \"has\" should be done on server\n                    // where we can access more info such as headers, HttpOnly cookie, etc.\n                    return [\n                        2,\n                        matchers.some(function(m) {\n                            return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n                        })\n                    ];\n            }\n        });\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var _ref = _sliced_to_array._((0, _resolvehref.resolveHref)(router, url, true), 2), resolvedHref = _ref[0], resolvedAs = _ref[1];\n    var origin = (0, _utils.getLocationOrigin)();\n    var hrefWasAbsolute = resolvedHref.startsWith(origin);\n    var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    var nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    var matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || undefined) {\n            var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            });\n            var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then(function(param) {\n                var _param = _sliced_to_array._(param, 2), pages = _param[0], _param_ = _param[1], rewrites = _param_.__rewrites;\n                var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) { var result; } else if (!pages.includes(fsPathname)) {\n                    var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref: resolvedHref\n                };\n            });\n        }\n        var src = (0, _parsepath.parsePath)(source);\n        var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n            nextConfig: nextConfig,\n            parseData: true\n        })), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        }));\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            var src1 = (0, _parsepath.parsePath)(redirectTarget);\n            var pathname1 = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src1.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            })), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            }));\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\" + pathname1 + src1.query + src1.hash,\n                newUrl: \"\" + pathname1 + src1.query + src1.hash\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nfunction _withMiddlewareEffects() {\n    _withMiddlewareEffects = _async_to_generator._(function(options) {\n        var matches, data, effect, e;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        matchesMiddleware(options)\n                    ];\n                case 1:\n                    matches = _state.sent();\n                    if (!matches || !options.fetchData) {\n                        return [\n                            2,\n                            null\n                        ];\n                    }\n                    _state.label = 2;\n                case 2:\n                    _state.trys.push([\n                        2,\n                        5,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        options.fetchData()\n                    ];\n                case 3:\n                    data = _state.sent();\n                    return [\n                        4,\n                        getMiddlewareData(data.dataHref, data.response, options)\n                    ];\n                case 4:\n                    effect = _state.sent();\n                    return [\n                        2,\n                        {\n                            dataHref: data.dataHref,\n                            json: data.json,\n                            response: data.response,\n                            text: data.text,\n                            cacheKey: data.cacheKey,\n                            effect: effect\n                        }\n                    ];\n                case 5:\n                    e = _state.sent();\n                    /**\r\n     * TODO: Revisit this in the future.\r\n     * For now we will not consider middleware data errors to be fatal.\r\n     * maybe we should revisit in the future.\r\n     */ return [\n                        2,\n                        null\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then(function(response) {\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    var dataHref = param.dataHref, inflightCache = param.inflightCache, isPrefetch = param.isPrefetch, hasMiddleware = param.hasMiddleware, isServerRender = param.isServerRender, parseJSON = param.parseJSON, persistCache = param.persistCache, isBackground = param.isBackground, unstable_skipClientCache = param.unstable_skipClientCache;\n    var _ref = new URL(dataHref, window.location.href), cacheKey = _ref.href;\n    var _params_method;\n    var getData = function(params) {\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n        }).then(function(response) {\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref: dataHref,\n                    response: response,\n                    text: \"\",\n                    json: {},\n                    cacheKey: cacheKey\n                };\n            }\n            return response.text().then(function(text) {\n                if (!response.ok) {\n                    /**\r\n             * When the data response is a redirect because of a middleware\r\n             * we do not consider it an error. The headers must bring the\r\n             * mapped location.\r\n             * TODO: Change the status code in the handler.\r\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref: dataHref,\n                            response: response,\n                            text: text,\n                            json: {},\n                            cacheKey: cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref: dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response: response,\n                                text: text,\n                                cacheKey: cacheKey\n                            };\n                        }\n                    }\n                    var error = new Error(\"Failed to load static props\");\n                    /**\r\n             * We should only trigger a server-side transition if this was\r\n             * caused on a client-side transition. Otherwise, we'd get into\r\n             * an infinite loop.\r\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref: dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response: response,\n                    text: text,\n                    cacheKey: cacheKey\n                };\n            });\n        }).then(function(data) {\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        })[\"catch\"](function(err) {\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then(function(data) {\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    var url = param.url, router = param.router;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nvar getCancelledHandler = function(param) {\n    var route = param.route, router = param.router;\n    var cancelled = false;\n    var cancel = router.clc = function() {\n        cancelled = true;\n    };\n    var handleCancelled = function() {\n        if (cancelled) {\n            var error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname, query, as, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _class_call_check._(this, Router);\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = function(e) {\n            var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n            _this.isFirstPopStateEvent = false;\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var _$pathname = _this.pathname, _$query = _this.query;\n                _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(_$pathname),\n                    query: _$query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, _$as = state.as, options = state.options, key = state.key;\n            if (false) { var v; }\n            _this._key = key;\n            var _$pathname1 = (0, _parserelativeurl.parseRelativeUrl)(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && _$as === (0, _addbasepath.addBasePath)(_this.asPath) && _$pathname1 === (0, _addbasepath.addBasePath)(_this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change(\"replaceState\", url, _$as, Object.assign({}, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        var route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== \"/_error\") {\n            this.components[route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (true) {\n            var BloomFilter = (__webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter.js\").BloomFilter);\n            var staticFilterData = {\"numItems\":0,\"errorRate\":0.01,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n            var dynamicFilterData = {\"numItems\":0,\"errorRate\":0.01,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                this._bfl_s[\"import\"](staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                this._bfl_d[\"import\"](dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route: route,\n            pathname: pathname,\n            query: query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback: isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options = {\n                    locale: locale\n                };\n                var asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale: locale,\n                    asPath: asPath\n                }).then(function(matches) {\n                    options._shouldResolveHref = as !== pathname;\n                    _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query: query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _create_class._(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\r\n   * Go back in history\r\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\r\n   * Go forward in history\r\n   */ key: \"forward\",\n            value: function forward() {\n                window.history.forward();\n            }\n        },\n        {\n            /**\r\n   * Performs a `pushState` with arguments\r\n   * @param url of the route\r\n   * @param as masks `url` for the browser\r\n   * @param options object you can define `shallow` and other options\r\n   */ key: \"push\",\n            value: function push(url, as, options) {\n                if (options === void 0) options = {};\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"pushState\", url, as, options);\n            }\n        },\n        {\n            /**\r\n   * Performs a `replaceState` with arguments\r\n   * @param url of the route\r\n   * @param as masks `url` for the browser\r\n   * @param options object you can define `shallow` and other options\r\n   */ key: \"replace\",\n            value: function replace(url, as, options) {\n                if (options === void 0) options = {};\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"replaceState\", url, as, options);\n            }\n        },\n        {\n            key: \"_bfl\",\n            value: function _bfl(as, resolvedAs, locale, skipNavigate) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var matchesBflStatic, matchesBflDynamic, _i, _iter, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i1, _iter1, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n                    return _ts_generator._(this, function(_state) {\n                        if (true) {\n                            matchesBflStatic = false;\n                            matchesBflDynamic = false;\n                            for(_i = 0, _iter = [\n                                as,\n                                resolvedAs\n                            ]; _i < _iter.length; _i++){\n                                curAs = _iter[_i];\n                                if (curAs) {\n                                    asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                                    asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || _this.locale));\n                                    if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(_this.asPath, \"http://n\").pathname)) {\n                                        ;\n                                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = _this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = _this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                                        for(_i1 = 0, _iter1 = [\n                                            asNoSlash,\n                                            asNoSlashLocale\n                                        ]; _i1 < _iter1.length; _i1++){\n                                            normalizedAS = _iter1[_i1];\n                                            curAsParts = normalizedAS.split(\"/\");\n                                            for(i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                                ;\n                                                currentPart = curAsParts.slice(0, i).join(\"/\");\n                                                if (currentPart && ((_this__bfl_d = _this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                                    matchesBflDynamic = true;\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        // if the client router filter is matched then we trigger\n                                        // a hard navigation\n                                        if (matchesBflStatic || matchesBflDynamic) {\n                                            if (skipNavigate) {\n                                                return [\n                                                    2,\n                                                    true\n                                                ];\n                                            }\n                                            handleHardNavigation({\n                                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || _this.locale, _this.defaultLocale)),\n                                                router: _this\n                                            });\n                                            return [\n                                                2,\n                                                new Promise(function() {})\n                                            ];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            2,\n                            false\n                        ];\n                    });\n                })();\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options_shallow, shallow, _options_scroll, scroll, routeProps, cleanedAs, localeChange, err, parsed, pathname, query, pages, rewrites, ref, ref1, err1, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, _tmp, rewritesResult, routeMatch, parsedAs1, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, routeRegex1, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs, newUrl, newAs, notFoundRoute, _, _routeInfo_route, isValidShallowRoute, _options_scroll1, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1, err2, canSkipUpdating, e, hashRegex, err3;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (!(0, _islocalurl.isLocalURL)(url)) {\n                                    handleHardNavigation({\n                                        url: url,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                isQueryUpdating = options._h === 1;\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    2\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, undefined, options.locale)\n                                ];\n                            case 1:\n                                _state.sent();\n                                _state.label = 2;\n                            case 2:\n                                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                                nextState = _object_spread._({}, _this.state);\n                                readyStateChange = _this.isReady !== true;\n                                _this.isReady = true;\n                                isSsr = _this.isSsr;\n                                if (!isQueryUpdating) {\n                                    _this.isSsr = false;\n                                }\n                                // if a route transition is already in progress before\n                                // the query updating is triggered ignore query updating\n                                if (isQueryUpdating && _this.clc) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                prevLocale = nextState.locale;\n                                if (false) {}\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark(\"routeChange\");\n                                }\n                                _options_shallow = options.shallow, shallow = _options_shallow === void 0 ? false : _options_shallow, _options_scroll = options.scroll, scroll = _options_scroll === void 0 ? true : _options_scroll;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (_this._inFlightRoute && _this.clc) {\n                                    if (!isSsr) {\n                                        Router.events.emit(\"routeChangeError\", buildCancellationError(), _this._inFlightRoute, routeProps);\n                                    }\n                                    _this.clc();\n                                    _this.clc = null;\n                                }\n                                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, _this.defaultLocale));\n                                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                                _this._inFlightRoute = as;\n                                localeChange = prevLocale !== nextState.locale;\n                                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) return [\n                                    3,\n                                    7\n                                ];\n                                nextState.asPath = cleanedAs;\n                                Router.events.emit(\"hashChangeStart\", as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                _this.changeState(method, url, as, _object_spread_props._(_object_spread._({}, options), {\n                                    scroll: false\n                                }));\n                                if (scroll) {\n                                    _this.scrollToHash(cleanedAs);\n                                }\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(nextState, _this.components[nextState.route], null)\n                                ];\n                            case 4:\n                                _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                err = _state.sent();\n                                if ((0, _iserror[\"default\"])(err) && err.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                                }\n                                throw err;\n                            case 6:\n                                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 7:\n                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                // if we detected the path as app route during prefetching\n                                // trigger hard navigation\n                                if ((_this_components_pathname = _this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                _state.label = 8;\n                            case 8:\n                                _state.trys.push([\n                                    8,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader.getPageList(),\n                                        (0, _routeloader.getClientBuildManifest)(),\n                                        _this.pageLoader.getMiddleware()\n                                    ])\n                                ];\n                            case 9:\n                                ref = _sliced_to_array._.apply(void 0, [\n                                    _state.sent(),\n                                    2\n                                ]), pages = ref[0], ref1 = ref[1], rewrites = ref1.__rewrites, ref1, ref;\n                                return [\n                                    3,\n                                    11\n                                ];\n                            case 10:\n                                err1 = _state.sent();\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                handleHardNavigation({\n                                    url: as,\n                                    router: _this\n                                });\n                                return [\n                                    2,\n                                    false\n                                ];\n                            case 11:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = \"replaceState\";\n                                }\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n                                _tmp = !options.shallow;\n                                if (!_tmp) return [\n                                    3,\n                                    13\n                                ];\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: as,\n                                        locale: nextState.locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 12:\n                                _tmp = _state.sent();\n                                _state.label = 13;\n                            case 13:\n                                isMiddlewareMatch = _tmp;\n                                if (isQueryUpdating && isMiddlewareMatch) {\n                                    shouldResolveHref = false;\n                                }\n                                if (shouldResolveHref && pathname !== \"/_error\") {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                                            if (!isMiddlewareMatch) {\n                                                url = (0, _formaturl.formatWithValidation)(parsed);\n                                            }\n                                        }\n                                    }\n                                }\n                                if (!(0, _islocalurl.isLocalURL)(as)) {\n                                    if (true) {\n                                        throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                                    }\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                routeMatch = false;\n                                if ((0, _isdynamic.isDynamicRoute)(route)) {\n                                    parsedAs1 = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                                    asPathname = parsedAs1.pathname;\n                                    routeRegex = (0, _routeregex.getRouteRegex)(route);\n                                    routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                                    shouldInterpolate = route === asPathname;\n                                    interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n                                    if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                                        missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                            return !query[param] && !routeRegex.groups[param].optional;\n                                        });\n                                        if (missingParams.length > 0 && !isMiddlewareMatch) {\n                                            if (true) {\n                                                console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                                            }\n                                            throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n                                        }\n                                    } else if (shouldInterpolate) {\n                                        as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs1, {\n                                            pathname: interpolatedAs.result,\n                                            query: (0, _omit.omit)(query, interpolatedAs.params)\n                                        }));\n                                    } else {\n                                        // Merge params into `query`, overwriting any specified in search\n                                        Object.assign(query, routeMatch);\n                                    }\n                                }\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeStart\", as, routeProps);\n                                }\n                                isErrorRoute = _this.pathname === \"/404\" || _this.pathname === \"/_error\";\n                                _state.label = 14;\n                            case 14:\n                                _state.trys.push([\n                                    14,\n                                    35,\n                                    ,\n                                    36\n                                ]);\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: route,\n                                        pathname: pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: routeProps,\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        hasMiddleware: isMiddlewareMatch,\n                                        unstable_skipClientCache: options.unstable_skipClientCache,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                                        isMiddlewareRewrite: isMiddlewareRewrite\n                                    })\n                                ];\n                            case 15:\n                                routeInfo = _state.sent();\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    17\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale)\n                                ];\n                            case 16:\n                                _state.sent();\n                                _state.label = 17;\n                            case 17:\n                                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                                    pathname = routeInfo.route || route;\n                                    route = pathname;\n                                    if (!routeProps.shallow) {\n                                        query = Object.assign({}, routeInfo.query || {}, query);\n                                    }\n                                    cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                                        Object.keys(routeMatch).forEach(function(key) {\n                                            if (routeMatch && query[key] === routeMatch[key]) {\n                                                delete query[key];\n                                            }\n                                        });\n                                    }\n                                    if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                                        prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                                        rewriteAs = prefixedAs;\n                                        if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                                            rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                                        }\n                                        if (false) {}\n                                        routeRegex1 = (0, _routeregex.getRouteRegex)(pathname);\n                                        curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex1)(new URL(rewriteAs, location.href).pathname);\n                                        if (curRouteMatch) {\n                                            Object.assign(query, curRouteMatch);\n                                        }\n                                    }\n                                }\n                                // If the routeInfo brings a redirect we simply apply it.\n                                if (\"type\" in routeInfo) {\n                                    if (routeInfo.type === \"redirect-internal\") {\n                                        return [\n                                            2,\n                                            _this.change(method, routeInfo.newUrl, routeInfo.newAs, options)\n                                        ];\n                                    } else {\n                                        handleHardNavigation({\n                                            url: routeInfo.destination,\n                                            router: _this\n                                        });\n                                        return [\n                                            2,\n                                            new Promise(function() {})\n                                        ];\n                                    }\n                                }\n                                component = routeInfo.Component;\n                                if (component && component.unstable_scriptLoader) {\n                                    scripts = [].concat(component.unstable_scriptLoader());\n                                    scripts.forEach(function(script) {\n                                        (0, _script.handleClientScriptLoad)(script.props);\n                                    });\n                                }\n                                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) return [\n                                    3,\n                                    23\n                                ];\n                                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                                    // Use the destination from redirect without adding locale\n                                    options.locale = false;\n                                    destination = routeInfo.props.pageProps.__N_REDIRECT;\n                                    // check if destination is internal (resolves to a page) and attempt\n                                    // client-navigation if it is falling back to hard navigation if\n                                    // it's not\n                                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                                        parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                        _prepareUrlAs = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs.url, newAs = _prepareUrlAs.as;\n                                        return [\n                                            2,\n                                            _this.change(method, newUrl, newAs, options)\n                                        ];\n                                    }\n                                    handleHardNavigation({\n                                        url: destination,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) return [\n                                    3,\n                                    23\n                                ];\n                                _state.label = 18;\n                            case 18:\n                                _state.trys.push([\n                                    18,\n                                    20,\n                                    ,\n                                    21\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/404\")\n                                ];\n                            case 19:\n                                _state.sent();\n                                notFoundRoute = \"/404\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 20:\n                                _ = _state.sent();\n                                notFoundRoute = \"/_error\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 21:\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: notFoundRoute,\n                                        pathname: notFoundRoute,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isNotFound: true\n                                    })\n                                ];\n                            case 22:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on /404\");\n                                }\n                                _state.label = 23;\n                            case 23:\n                                if (isQueryUpdating && _this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                                shouldScroll = (_options_scroll1 = options.scroll) != null ? _options_scroll1 : !isQueryUpdating && !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                                upcomingRouterState = _object_spread_props._(_object_spread._({}, nextState), {\n                                    route: route,\n                                    pathname: pathname,\n                                    query: query,\n                                    asPath: cleanedAs,\n                                    isFallback: false\n                                });\n                                if (!(isQueryUpdating && isErrorRoute)) return [\n                                    3,\n                                    29\n                                ];\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: _this.pathname,\n                                        pathname: _this.pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback\n                                    })\n                                ];\n                            case 24:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on \" + _this.pathname);\n                                }\n                                if (_this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                _state.label = 25;\n                            case 25:\n                                _state.trys.push([\n                                    25,\n                                    27,\n                                    ,\n                                    28\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 26:\n                                _state.sent();\n                                return [\n                                    3,\n                                    28\n                                ];\n                            case 27:\n                                err2 = _state.sent();\n                                if ((0, _iserror[\"default\"])(err2) && err2.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err2, cleanedAs, routeProps);\n                                }\n                                throw err2;\n                            case 28:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 29:\n                                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                                _this.changeState(method, url, as, options);\n                                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, _this.state);\n                                if (!!canSkipUpdating) return [\n                                    3,\n                                    34\n                                ];\n                                _state.label = 30;\n                            case 30:\n                                _state.trys.push([\n                                    30,\n                                    32,\n                                    ,\n                                    33\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 31:\n                                _state.sent();\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 32:\n                                e = _state.sent();\n                                if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                                else throw e;\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 33:\n                                if (routeInfo.error) {\n                                    if (!isQueryUpdating) {\n                                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                                    }\n                                    throw routeInfo.error;\n                                }\n                                if (false) {}\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                                }\n                                hashRegex = /#.+$/;\n                                if (shouldScroll && hashRegex.test(as)) {\n                                    _this.scrollToHash(as);\n                                }\n                                _state.label = 34;\n                            case 34:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 35:\n                                err3 = _state.sent();\n                                if ((0, _iserror[\"default\"])(err3) && err3.cancelled) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                throw err3;\n                            case 36:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as, options) {\n                if (options === void 0) options = {};\n                if (true) {\n                    if (typeof window.history === \"undefined\") {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === \"undefined\") {\n                        console.error(\"Warning: window.history.\" + method + \" is not available\");\n                        return;\n                    }\n                }\n                if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        key: this._key = method !== \"pushState\" ? this._key : createKey()\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n                    \"\", as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var props, _ref, Component, styleSheets, routeInfo, gipErr, routeInfoErr;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                console.error(err);\n                                if (err.cancelled) {\n                                    // bubble up cancellation errors\n                                    throw err;\n                                }\n                                if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n                                    Router.events.emit(\"routeChangeError\", err, as, routeProps);\n                                    // If we can't load the page it could be one of following reasons\n                                    //  1. Page doesn't exists\n                                    //  2. Page does exist in a different zone\n                                    //  3. Internal error while loading the page\n                                    // So, doing a hard reload is the proper way to deal with this.\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    // Changing the URL doesn't block executing the current code path.\n                                    // So let's throw a cancellation error stop the routing logic.\n                                    throw buildCancellationError();\n                                }\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    7,\n                                    ,\n                                    8\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/_error\")\n                                ];\n                            case 2:\n                                _ref = _state.sent(), Component = _ref.page, styleSheets = _ref.styleSheets;\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (!!routeInfo.props) return [\n                                    3,\n                                    6\n                                ];\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.getInitialProps(Component, {\n                                        err: err,\n                                        pathname: pathname,\n                                        query: query\n                                    })\n                                ];\n                            case 4:\n                                routeInfo.props = _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                gipErr = _state.sent();\n                                console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                                routeInfo.props = {};\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 6:\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 7:\n                                routeInfoErr = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _iserror[\"default\"])(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true)\n                                ];\n                            case 8:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(param) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, _tmp, resolvedRoute, pages, routeInfo, _tmp1, isValidElementType, wasBailedPrefetch, shouldFetchData, _ref, props, cacheKey, err;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                                route = requestedRoute;\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                existingInfo = _this.components[route];\n                                if (routeProps.shallow && existingInfo && _this.route === route) {\n                                    return [\n                                        2,\n                                        existingInfo\n                                    ];\n                                }\n                                if (hasMiddleware) {\n                                    existingInfo = undefined;\n                                }\n                                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n                                isBackground = isQueryUpdating;\n                                fetchNextDataParams = {\n                                    dataHref: _this.pageLoader.getDataHref({\n                                        href: (0, _formaturl.formatWithValidation)({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        skipInterpolation: true,\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale\n                                    }),\n                                    hasMiddleware: true,\n                                    isServerRender: _this.isSsr,\n                                    parseJSON: true,\n                                    inflightCache: isBackground ? _this.sbc : _this.sdc,\n                                    persistCache: !isPreview,\n                                    isPrefetch: false,\n                                    unstable_skipClientCache: unstable_skipClientCache,\n                                    isBackground: isBackground\n                                };\n                                if (!(isQueryUpdating && !isMiddlewareRewrite)) return [\n                                    3,\n                                    2\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    4\n                                ];\n                            case 2:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData(fetchNextDataParams);\n                                        },\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale,\n                                        router: _this\n                                    })[\"catch\"](function(err) {\n                                        // we don't hard error during query updating\n                                        // as it's un-necessary and doesn't need to be fatal\n                                        // unless it is a fallback route and the props can't\n                                        // be loaded\n                                        if (isQueryUpdating) {\n                                            return null;\n                                        }\n                                        throw err;\n                                    })\n                                ];\n                            case 3:\n                                _tmp = _state.sent();\n                                _state.label = 4;\n                            case 4:\n                                data = _tmp;\n                                // when rendering error routes we don't apply middleware\n                                // effects\n                                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                                    data.effect = undefined;\n                                }\n                                if (isQueryUpdating) {\n                                    if (!data) {\n                                        data = {\n                                            json: self.__NEXT_DATA__.props\n                                        };\n                                    } else {\n                                        data.json = self.__NEXT_DATA__.props;\n                                    }\n                                }\n                                handleCancelled();\n                                if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n                                    return [\n                                        2,\n                                        data.effect\n                                    ];\n                                }\n                                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) return [\n                                    3,\n                                    6\n                                ];\n                                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 5:\n                                pages = _state.sent();\n                                // during query updating the page must match although during\n                                // client-transition a redirect that doesn't match a page\n                                // can be returned and this should trigger a hard navigation\n                                // which is valid for incremental migration\n                                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                                    route = resolvedRoute;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _object_spread._({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, _this.locales).pathname);\n                                    // Check again the cache with the new destination.\n                                    existingInfo = _this.components[route];\n                                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                                        // If we have a match with the current route due to rewrite,\n                                        // we can copy the existing information to the rewritten one.\n                                        // Then, we return the information along with the matched route.\n                                        return [\n                                            2,\n                                            _object_spread_props._(_object_spread._({}, existingInfo), {\n                                                route: route\n                                            })\n                                        ];\n                                    }\n                                }\n                                _state.label = 6;\n                            case 6:\n                                if ((0, _isapiroute.isAPIRoute)(route)) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                _tmp1 = cachedRouteInfo;\n                                if (_tmp1) return [\n                                    3,\n                                    8\n                                ];\n                                return [\n                                    4,\n                                    _this.fetchComponent(route).then(function(res) {\n                                        return {\n                                            Component: res.page,\n                                            styleSheets: res.styleSheets,\n                                            __N_SSG: res.mod.__N_SSG,\n                                            __N_SSP: res.mod.__N_SSP\n                                        };\n                                    })\n                                ];\n                            case 7:\n                                _tmp1 = _state.sent();\n                                _state.label = 8;\n                            case 8:\n                                routeInfo = _tmp1;\n                                if (true) {\n                                    isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                                    if (!isValidElementType(routeInfo.Component)) {\n                                        throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                                    }\n                                }\n                                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n                                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                                // For non-SSG prefetches that bailed before sending data\n                                // we clear the cache to fetch full response\n                                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                                    delete _this.sdc[data.dataHref];\n                                }\n                                return [\n                                    4,\n                                    _this._getData(/*#__PURE__*/ _async_to_generator._(function() {\n                                        var dataHref, fetched, _tmp;\n                                        return _ts_generator._(this, function(_state) {\n                                            switch(_state.label){\n                                                case 0:\n                                                    if (!shouldFetchData) return [\n                                                        3,\n                                                        2\n                                                    ];\n                                                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                                                        return [\n                                                            2,\n                                                            {\n                                                                cacheKey: data.cacheKey,\n                                                                props: data.json\n                                                            }\n                                                        ];\n                                                    }\n                                                    dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({\n                                                        href: (0, _formaturl.formatWithValidation)({\n                                                            pathname: pathname,\n                                                            query: query\n                                                        }),\n                                                        asPath: resolvedAs,\n                                                        locale: locale\n                                                    });\n                                                    return [\n                                                        4,\n                                                        fetchNextData({\n                                                            dataHref: dataHref,\n                                                            isServerRender: _this.isSsr,\n                                                            parseJSON: true,\n                                                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                                                            persistCache: !isPreview,\n                                                            isPrefetch: false,\n                                                            unstable_skipClientCache: unstable_skipClientCache\n                                                        })\n                                                    ];\n                                                case 1:\n                                                    fetched = _state.sent();\n                                                    return [\n                                                        2,\n                                                        {\n                                                            cacheKey: fetched.cacheKey,\n                                                            props: fetched.json || {}\n                                                        }\n                                                    ];\n                                                case 2:\n                                                    _tmp = {\n                                                        headers: {}\n                                                    };\n                                                    return [\n                                                        4,\n                                                        _this.getInitialProps(routeInfo.Component, {\n                                                            pathname: pathname,\n                                                            query: query,\n                                                            asPath: as,\n                                                            locale: locale,\n                                                            locales: _this.locales,\n                                                            defaultLocale: _this.defaultLocale\n                                                        })\n                                                    ];\n                                                case 3:\n                                                    return [\n                                                        2,\n                                                        (_tmp.props = _state.sent(), _tmp)\n                                                    ];\n                                            }\n                                        });\n                                    }))\n                                ];\n                            case 9:\n                                _ref = _state.sent(), props = _ref.props, cacheKey = _ref.cacheKey;\n                                // Only bust the data cache for SSP routes although\n                                // middleware can skip cache per request with\n                                // x-middleware-cache: no-cache as well\n                                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                                    delete _this.sdc[cacheKey];\n                                }\n                                // we kick off a HEAD request in the background\n                                // when a non-prefetch request is made to signal revalidation\n                                if (!_this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n                                props.pageProps = Object.assign({}, props.pageProps);\n                                routeInfo.props = props;\n                                routeInfo.route = route;\n                                routeInfo.query = query;\n                                routeInfo.resolvedAs = resolvedAs;\n                                _this.components[route] = routeInfo;\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 10:\n                                err = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps)\n                                ];\n                            case 11:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(state, data, resetScroll) {\n                this.state = state;\n                return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n            }\n        },\n        {\n            /**\r\n   * Callback to execute before replacing router state\r\n   * @param cb callback to be executed\r\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var _this_asPath_split = _sliced_to_array._(this.asPath.split(\"#\"), 2), oldUrlNoHash = _this_asPath_split[0], oldHash = _this_asPath_split[1];\n                var _as_split = _sliced_to_array._(as.split(\"#\"), 2), newUrlNoHash = _as_split[0], newHash = _as_split[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var _as_split = _sliced_to_array._(as.split(\"#\"), 2), tmp = _as_split[1], hash = tmp === void 0 ? \"\" : tmp;\n                // Scroll to top if the hash is just `#` with no value or `#top`\n                // To mirror browsers\n                if (hash === \"\" || hash === \"top\") {\n                    (0, _handlesmoothscroll.handleSmoothScroll)(function() {\n                        return window.scrollTo(0, 0);\n                    });\n                    return;\n                }\n                // Decode hash to make non-latin anchor works.\n                var rawHash = decodeURIComponent(hash);\n                // First we check if the element by id is found\n                var idEl = document.getElementById(rawHash);\n                if (idEl) {\n                    (0, _handlesmoothscroll.handleSmoothScroll)(function() {\n                        return idEl.scrollIntoView();\n                    });\n                    return;\n                }\n                // If there's no element with the id, we check the `name` property\n                // To mirror browsers\n                var nameEl = document.getElementsByName(rawHash)[0];\n                if (nameEl) {\n                    (0, _handlesmoothscroll.handleSmoothScroll)(function() {\n                        return nameEl.scrollIntoView();\n                    });\n                }\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\r\n   * Prefetch page code, you may wait for the data during page rendering.\r\n   * This feature only works in production!\r\n   * @param url the href of prefetched page\r\n   * @param asPath the as path of the prefetched page\r\n   */ function prefetch(url, asPath, options) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, ref, rewritesResult, data, _tmp, route;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (asPath === void 0) asPath = url;\n                                if (options === void 0) options = {};\n                                // Prefetch is not supported in development mode because it would trigger on-demand-entries\n                                if (true) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n                                    // No prefetches for bots that render the link since they are typically navigating\n                                    // links via the equivalent of a hard navigation and hence never utilize these\n                                    // prefetches.\n                                    return [\n                                        2\n                                    ];\n                                }\n                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                                urlPathname = parsed.pathname;\n                                pathname = parsed.pathname, query = parsed.query;\n                                originalPathname = pathname;\n                                if (false) {}\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 1:\n                                pages = _state.sent();\n                                resolvedAs = asPath;\n                                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this.locale;\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 2:\n                                isMiddlewareMatch = _state.sent();\n                                if (true) return [\n                                    3,\n                                    4\n                                ];\n                                return [\n                                    4,\n                                    (0, _routeloader.getClientBuildManifest)()\n                                ];\n                            case 3:\n                                ref = _state.sent(), rewrites = ref.__rewrites, ref;\n                                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, _this.locale), true), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, _this.locales);\n                                if (rewritesResult.externalDest) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if (!isMiddlewareMatch) {\n                                    resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), _this.locale);\n                                }\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formaturl.formatWithValidation)(parsed);\n                                    }\n                                }\n                                _state.label = 4;\n                            case 4:\n                                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                                    pathname = parsed.pathname;\n                                    parsed.pathname = pathname;\n                                    Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formaturl.formatWithValidation)(parsed);\n                                    }\n                                }\n                                if (true) return [\n                                    3,\n                                    5\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    7\n                                ];\n                            case 5:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData({\n                                                dataHref: _this.pageLoader.getDataHref({\n                                                    href: (0, _formaturl.formatWithValidation)({\n                                                        pathname: originalPathname,\n                                                        query: query\n                                                    }),\n                                                    skipInterpolation: true,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                hasMiddleware: true,\n                                                isServerRender: _this.isSsr,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true\n                                            });\n                                        },\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 6:\n                                _tmp = _state.sent();\n                                _state.label = 7;\n                            case 7:\n                                data = _tmp;\n                                /**\r\n     * If there was a rewrite we apply the effects of the rewrite on the\r\n     * current parameters for the prefetch.\r\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                                    parsed.pathname = data.effect.resolvedHref;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _object_spread._({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = data.effect.parsedAs.pathname;\n                                    url = (0, _formaturl.formatWithValidation)(parsed);\n                                }\n                                /**\r\n     * If there is a redirect to an external destination then we don't have\r\n     * to prefetch content as it will be unused.\r\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                return [\n                                    4,\n                                    _this._bfl(asPath, resolvedAs, options.locale, true)\n                                ];\n                            case 8:\n                                if (_state.sent()) {\n                                    _this.components[urlPathname] = {\n                                        __appRouter: true\n                                    };\n                                }\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader._isSsg(route).then(function(isSsg) {\n                                            return isSsg ? fetchNextData({\n                                                dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                                                    href: url,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                isServerRender: false,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true,\n                                                unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                                            }).then(function() {\n                                                return false;\n                                            })[\"catch\"](function() {\n                                                return false;\n                                            }) : false;\n                                        }),\n                                        _this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n                                    ])\n                                ];\n                            case 9:\n                                _state.sent();\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var handleCancelled, componentResult, err;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    3,\n                                    ,\n                                    4\n                                ]);\n                                return [\n                                    4,\n                                    _this.pageLoader.loadPage(route)\n                                ];\n                            case 2:\n                                componentResult = _state.sent();\n                                handleCancelled();\n                                return [\n                                    2,\n                                    componentResult\n                                ];\n                            case 3:\n                                err = _state.sent();\n                                handleCancelled();\n                                throw err;\n                            case 4:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error(\"Loading initial props cancelled\");\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                // Do not cache RSC flight response since it's not a static resource\n                return fetchNextData({\n                    dataHref: dataHref,\n                    isServerRender: true,\n                    parseJSON: false,\n                    inflightCache: this.sdc,\n                    persistCache: false,\n                    isPrefetch: false\n                }).then(function(param) {\n                    var text = param.text;\n                    return {\n                        data: text\n                    };\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var _this_components__app = this.components[\"/_app\"], App = _this_components__app.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils.loadGetInitialProps)(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"route\",\n            get: function get() {\n                return this.state.route;\n            }\n        },\n        {\n            key: \"pathname\",\n            get: function get() {\n                return this.state.pathname;\n            }\n        },\n        {\n            key: \"query\",\n            get: function get() {\n                return this.state.query;\n            }\n        },\n        {\n            key: \"asPath\",\n            get: function get() {\n                return this.state.asPath;\n            }\n        },\n        {\n            key: \"locale\",\n            get: function get() {\n                return this.state.locale;\n            }\n        },\n        {\n            key: \"isFallback\",\n            get: function get() {\n                return this.state.isFallback;\n            }\n        },\n        {\n            key: \"isPreview\",\n            get: function get() {\n                return this.state.isPreview;\n            }\n        }\n    ]);\n    return Router;\n}();\n(function() {\n    Router.events = (0, _mitt[\"default\"])();\n})(); //# sourceMappingURL=router.js.map\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports on update so we can compare the boundary\r\n                // signatures.\r\n                module.hot.dispose(function (data) {\r\n                    data.prevExports = currentExports;\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevExports !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevExports !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0QkFBNEI7QUFDZjs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGVBQWVRLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUU4sU0FBUztJQUNiRyxXQUFTLFNBQVRBO1FBQ0ksT0FBT1M7SUFDWDtJQUNBUixtQkFBbUIsU0FBbkJBO1FBQ0ksT0FBT0E7SUFDWDtJQUNBQyxXQUFXLFNBQVhBO1FBQ0ksT0FBT0E7SUFDWDtBQUNKO0FBQ0EsSUFBTVEsMkJBQTJCQyxtQkFBT0EsQ0FBQyw0R0FBeUM7QUFDbEYsSUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyw4R0FBMEM7QUFDcEYsSUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnSEFBK0I7QUFDcEUsSUFBTUcsZUFBZUgsbUJBQU9BLENBQUMscUZBQThCO0FBQzNELElBQU1JLFVBQVVKLG1CQUFPQSxDQUFDLHlFQUF3QjtBQUNoRCxJQUFNSyxXQUFXLFdBQVcsR0FBR0osMEJBQTBCSyxFQUFFTixtQkFBT0EsQ0FBQyx1RUFBdUI7QUFDMUYsSUFBTU8sdUJBQXVCUCxtQkFBT0EsQ0FBQyxrSEFBb0M7QUFDekUsSUFBTVEsdUJBQXVCUixtQkFBT0EsQ0FBQyx3R0FBK0I7QUFDcEUsSUFBTVMsUUFBUSxXQUFXLEdBQUdWLHlCQUF5Qk8sRUFBRU4sbUJBQU9BLENBQUMsNERBQVM7QUFDeEUsSUFBTVUsU0FBU1YsbUJBQU9BLENBQUMsOERBQVU7QUFDakMsSUFBTVcsYUFBYVgsbUJBQU9BLENBQUMsMEZBQW9C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QUNITixNQUFNTTtvQkFDVjtnQkFDSjtZQUNKOzs7WUFDQXdQLEtBQUFBO21CQUFBQSxTQUFBQSxnQkFBZ0I3TCxTQUFTLEVBQUVnUCxHQUFHO2dCQUMxQixJQUE0Qiw0QkFBSSxDQUFDaE4sVUFBVSxDQUFDLFFBQVEsRUFBNUNoQyxNQUFvQixzQkFBcEJBO2dCQUNSLElBQU1pUCxVQUFVLElBQUksQ0FBQ3pMLFNBQVMxRDtnQkFDOUJrUCxJQUFJQyxVQUFVQTtnQkFDZCxPQUFPLENBQUMsR0FBR25iLE9BQU9vYixtQkFBa0IsRUFBR3BQLEtBQUs7b0JBQ3hDbVAsU0FBQUE7b0JBQ0FqUCxXQUFBQTtvQkFDQS9KLFFBQVEsSUFBSTtvQkFDWitZLEtBQUFBO2dCQUNKO1lBQ0o7OztZQUNJdlAsS0FBQUE7aUJBQUo7Z0JBQ0ksT0FBTyxJQUFJLENBQUNpQixNQUFNakI7WUFDdEI7OztZQUNJbkosS0FBQUE7aUJBQUo7Z0JBQ0ksT0FBTyxJQUFJLENBQUNvSyxNQUFNcEs7WUFDdEI7OztZQUNJdUUsS0FBQUE7aUJBQUo7Z0JBQ0ksT0FBTyxJQUFJLENBQUM2RixNQUFNN0Y7WUFDdEI7OztZQUNJeEUsS0FBQUE7aUJBQUo7Z0JBQ0ksT0FBTyxJQUFJLENBQUNxSyxNQUFNcks7WUFDdEI7OztZQUNJTSxLQUFBQTtpQkFBSjtnQkFDSSxPQUFPLElBQUksQ0FBQytKLE1BQU0vSjtZQUN0Qjs7O1lBQ0l1SixLQUFBQTtpQkFBSjtnQkFDSSxPQUFPLElBQUksQ0FBQ1EsTUFBTVI7WUFDdEI7OztZQUNJRSxLQUFBQTtpQkFBSjtnQkFDSSxPQUFPLElBQUksQ0FBQ00sTUFBTU47WUFDdEI7OztXQWxtQ0VsTjs7QUEyeENMO0lBQ0dBLE9BQU9nUSxTQUFTLENBQUMsR0FBR3JQLEtBQU1wQixDQUFBQSxVQUFPO0FBQ3JDLE1BRUEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzPzg2ODQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxyXG5cInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgbWF0Y2hlc01pZGRsZXdhcmU6IG51bGwsXHJcbiAgICBjcmVhdGVLZXk6IG51bGxcclxufSk7XHJcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcclxuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cclxuICAgIH0pO1xyXG59XHJcbl9leHBvcnQoZXhwb3J0cywge1xyXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFJvdXRlcjtcclxuICAgIH0sXHJcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNNaWRkbGV3YXJlO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUtleTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUtleTtcclxuICAgIH1cclxufSk7XHJcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XHJcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcclxuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XHJcbmNvbnN0IF9yb3V0ZWxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xyXG5jb25zdCBfc2NyaXB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9zY3JpcHRcIik7XHJcbmNvbnN0IF9pc2Vycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XHJcbmNvbnN0IF9kZW5vcm1hbGl6ZXBhZ2VwYXRoID0gcmVxdWlyZShcIi4uL3BhZ2UtcGF0aC9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XHJcbmNvbnN0IF9ub3JtYWxpemVsb2NhbGVwYXRoID0gcmVxdWlyZShcIi4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoXCIpO1xyXG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL21pdHRcIikpO1xyXG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XHJcbmNvbnN0IF9pc2R5bmFtaWMgPSByZXF1aXJlKFwiLi91dGlscy9pcy1keW5hbWljXCIpO1xyXG5jb25zdCBfcGFyc2VyZWxhdGl2ZXVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcclxuY29uc3QgX3Jlc29sdmVyZXdyaXRlcyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XHJcbmNvbnN0IF9yb3V0ZW1hdGNoZXIgPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1tYXRjaGVyXCIpO1xyXG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xyXG5jb25zdCBfZm9ybWF0dXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcclxuY29uc3QgX2RldGVjdGRvbWFpbmxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIik7XHJcbmNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1wYXRoXCIpO1xyXG5jb25zdCBfYWRkbG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xyXG5jb25zdCBfcmVtb3ZlbG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZW1vdmUtbG9jYWxlXCIpO1xyXG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGhcIik7XHJcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcclxuY29uc3QgX2hhc2Jhc2VwYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9oYXMtYmFzZS1wYXRoXCIpO1xyXG5jb25zdCBfaXNhcGlyb3V0ZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtYXBpLXJvdXRlXCIpO1xyXG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XHJcbmNvbnN0IF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mb1wiKTtcclxuY29uc3QgX2NvbXBhcmVzdGF0ZXMgPSByZXF1aXJlKFwiLi91dGlscy9jb21wYXJlLXN0YXRlc1wiKTtcclxuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XHJcbmNvbnN0IF9pc2JvdCA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWJvdFwiKTtcclxuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi91dGlscy9vbWl0XCIpO1xyXG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLWhyZWZcIik7XHJcbmNvbnN0IF9pbnRlcnBvbGF0ZWFzID0gcmVxdWlyZShcIi4vdXRpbHMvaW50ZXJwb2xhdGUtYXNcIik7XHJcbmNvbnN0IF9oYW5kbGVzbW9vdGhzY3JvbGwgPSByZXF1aXJlKFwiLi91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcclxuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihcIlJvdXRlIENhbmNlbGxlZFwiKSwge1xyXG4gICAgICAgIGNhbmNlbGxlZDogdHJ1ZVxyXG4gICAgfSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucykge1xyXG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xyXG4gICAgaWYgKCFtYXRjaGVycykgcmV0dXJuIGZhbHNlO1xyXG4gICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkob3B0aW9ucy5hc1BhdGgpO1xyXG4gICAgLy8gcmVtb3ZlIGJhc2VQYXRoIGZpcnN0IHNpbmNlIHBhdGggcHJlZml4IGhhcyB0byBiZSBpbiB0aGUgb3JkZXIgb2YgYC8ke2Jhc2VQYXRofS8ke2xvY2FsZX1gXHJcbiAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aG5hbWUpIDogYXNQYXRobmFtZTtcclxuICAgIGNvbnN0IGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShjbGVhbmVkQXMsIG9wdGlvbnMubG9jYWxlKSk7XHJcbiAgICAvLyBDaGVjayBvbmx5IHBhdGggbWF0Y2ggb24gY2xpZW50LiBNYXRjaGluZyBcImhhc1wiIHNob3VsZCBiZSBkb25lIG9uIHNlcnZlclxyXG4gICAgLy8gd2hlcmUgd2UgY2FuIGFjY2VzcyBtb3JlIGluZm8gc3VjaCBhcyBoZWFkZXJzLCBIdHRwT25seSBjb29raWUsIGV0Yy5cclxuICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtKT0+bmV3IFJlZ0V4cChtLnJlZ2V4cCkudGVzdChhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xyXG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcclxuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyLCB1cmwsIGFzKSB7XHJcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcclxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXHJcbiAgICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIHVybCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xyXG4gICAgY29uc3QgaHJlZldhc0Fic29sdXRlID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKTtcclxuICAgIGNvbnN0IGFzV2FzQWJzb2x1dGUgPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xyXG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcclxuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xyXG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmV2FzQWJzb2x1dGUgPyByZXNvbHZlZEhyZWYgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShyZXNvbHZlZEhyZWYpO1xyXG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4oKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVybDogcHJlcGFyZWRVcmwsXHJcbiAgICAgICAgYXM6IGFzV2FzQWJzb2x1dGUgPyBwcmVwYXJlZEFzIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocHJlcGFyZWRBcylcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcclxuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9kZW5vcm1hbGl6ZXBhZ2VwYXRoLmRlbm9ybWFsaXplUGFnZVBhdGgpKHBhdGhuYW1lKSk7XHJcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgY2xlYW5QYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIpIHtcclxuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XHJcbiAgICB9XHJcbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXHJcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxyXG4gICAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpPT57XHJcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFnZSkgJiYgKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFnZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcclxufVxyXG5mdW5jdGlvbiBnZXRNaWRkbGV3YXJlRGF0YShzb3VyY2UsIHJlc3BvbnNlLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBuZXh0Q29uZmlnID0ge1xyXG4gICAgICAgIGJhc2VQYXRoOiBvcHRpb25zLnJvdXRlci5iYXNlUGF0aCxcclxuICAgICAgICBpMThuOiB7XHJcbiAgICAgICAgICAgIGxvY2FsZXM6IG9wdGlvbnMucm91dGVyLmxvY2FsZXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYWlsaW5nU2xhc2g6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJld3JpdGVcIik7XHJcbiAgICBsZXQgcmV3cml0ZVRhcmdldCA9IHJld3JpdGVIZWFkZXIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1tYXRjaGVkLXBhdGhcIik7XHJcbiAgICBjb25zdCBtYXRjaGVkUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1tYXRjaGVkLXBhdGhcIik7XHJcbiAgICBpZiAobWF0Y2hlZFBhdGggJiYgIXJld3JpdGVUYXJnZXQgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiX19uZXh0X2RhdGFfY2F0Y2hhbGxcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiL19lcnJvclwiKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCIvNDA0XCIpKSB7XHJcbiAgICAgICAgLy8gbGV2ZXJhZ2UgeC1tYXRjaGVkLXBhdGggdG8gZGV0ZWN0IG5leHQuY29uZmlnLmpzIHJld3JpdGVzXHJcbiAgICAgICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoO1xyXG4gICAgfVxyXG4gICAgaWYgKHJld3JpdGVUYXJnZXQpIHtcclxuICAgICAgICBpZiAocmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKFwiL1wiKSB8fCBwcm9jZXNzLmVudi5fX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV3cml0ZVRhcmdldCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXdyaXRlVGFyZ2V0KTtcclxuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWVJbmZvID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUsIHtcclxuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXHJcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBmc1BhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lSW5mby5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXHJcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKClcclxuICAgICAgICAgICAgXSkudGhlbigocGFyYW0pPT57XHJcbiAgICAgICAgICAgICAgICBsZXQgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IHBhcmFtO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFzID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXRobmFtZUluZm8ucGF0aG5hbWUsIHBhdGhuYW1lSW5mby5sb2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShhcykgfHwgIXJld3JpdGVIZWFkZXIgJiYgcGFnZXMuaW5jbHVkZXMoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKCgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShzb3VyY2UpLnBhdGhuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb25maWc6IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgPyB1bmRlZmluZWQgOiBuZXh0Q29uZmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IGFzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KShhcywgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCAocGF0aCk9PnJlc29sdmVEeW5hbWljUm91dGUocGF0aCwgcGFnZXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzID0gcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzUGF0aG5hbWUgPSByZXNvbHZlZFBhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9ICFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSA/IHJlc29sdmVEeW5hbWljUm91dGUoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSwgcGFnZXMpIDogZnNQYXRobmFtZTtcclxuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocmVzb2x2ZWRIcmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyZXNvbHZlZEhyZWYpKShhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCBtYXRjaGVzIHx8IHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZXdyaXRlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3JjID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShzb3VyY2UpO1xyXG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcclxuICAgICAgICAgICAgLi4uKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHNyYy5wYXRobmFtZSwge1xyXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcclxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcclxuICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXHJcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVkaXJlY3RUYXJnZXQgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJlZGlyZWN0XCIpO1xyXG4gICAgaWYgKHJlZGlyZWN0VGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkocmVkaXJlY3RUYXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZSA9ICgwLCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mby5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKSh7XHJcbiAgICAgICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcclxuICAgICAgICAgICAgICAgIGJ1aWxkSWQ6IFwiXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1pbnRlcm5hbFwiLFxyXG4gICAgICAgICAgICAgICAgbmV3QXM6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoLFxyXG4gICAgICAgICAgICAgICAgbmV3VXJsOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtZXh0ZXJuYWxcIixcclxuICAgICAgICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICB0eXBlOiBcIm5leHRcIlxyXG4gICAgfSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmVFZmZlY3RzKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKTtcclxuICAgIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IG9wdGlvbnMuZmV0Y2hEYXRhKCk7XHJcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gYXdhaXQgZ2V0TWlkZGxld2FyZURhdGEoZGF0YS5kYXRhSHJlZiwgZGF0YS5yZXNwb25zZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YUhyZWY6IGRhdGEuZGF0YUhyZWYsXHJcbiAgICAgICAgICAgIGpzb246IGRhdGEuanNvbixcclxuICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXHJcbiAgICAgICAgICAgIHRleHQ6IGRhdGEudGV4dCxcclxuICAgICAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXHJcbiAgICAgICAgICAgIGVmZmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgKiBUT0RPOiBSZXZpc2l0IHRoaXMgaW4gdGhlIGZ1dHVyZS5cclxuICAgICAqIEZvciBub3cgd2Ugd2lsbCBub3QgY29uc2lkZXIgbWlkZGxld2FyZSBkYXRhIGVycm9ycyB0byBiZSBmYXRhbC5cclxuICAgICAqIG1heWJlIHdlIHNob3VsZCByZXZpc2l0IGluIHRoZSBmdXR1cmUuXHJcbiAgICAgKi8gcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJzY3JvbGxSZXN0b3JhdGlvblwiIGluIHdpbmRvdy5oaXN0b3J5ICYmICEhZnVuY3Rpb24oKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGxldCB2ID0gXCJfX25leHRcIjtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXHJcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XHJcbiAgICB9IGNhdGNoIChuKSB7fVxyXG59KCk7XHJcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbChcIlNTR19EQVRBX05PVF9GT1VORFwiKTtcclxuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XHJcbiAgICAgICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXHJcbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XHJcbiAgICAgICAgLy8gPiBvcHRpb24uXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcclxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXHJcbiAgICAgICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xyXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXHJcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xyXG4gICAgICAgICAgICBcIngtbmV4dGpzLWRhdGFcIjogXCIxXCJcclxuICAgICAgICB9KVxyXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XHJcbiAgICAgICAgcmV0dXJuICFyZXNwb25zZS5vayAmJiBhdHRlbXB0cyA+IDEgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDUwMCA/IGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdGlvbnMpIDogcmVzcG9uc2U7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEocGFyYW0pIHtcclxuICAgIGxldCB7IGRhdGFIcmVmICwgaW5mbGlnaHRDYWNoZSAsIGlzUHJlZmV0Y2ggLCBoYXNNaWRkbGV3YXJlICwgaXNTZXJ2ZXJSZW5kZXIgLCBwYXJzZUpTT04gLCBwZXJzaXN0Q2FjaGUgLCBpc0JhY2tncm91bmQgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgIH0gPSBwYXJhbTtcclxuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICB2YXIgX3BhcmFtc19tZXRob2Q7XHJcbiAgICBjb25zdCBnZXREYXRhID0gKHBhcmFtcyk9PntcclxuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBpc1ByZWZldGNoID8ge1xyXG4gICAgICAgICAgICAgICAgcHVycG9zZTogXCJwcmVmZXRjaFwiXHJcbiAgICAgICAgICAgIH0gOiB7fSwgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8ge1xyXG4gICAgICAgICAgICAgICAgXCJ4LW1pZGRsZXdhcmUtcHJlZmV0Y2hcIjogXCIxXCJcclxuICAgICAgICAgICAgfSA6IHt9KSxcclxuICAgICAgICAgICAgbWV0aG9kOiAoX3BhcmFtc19tZXRob2QgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyBfcGFyYW1zX21ldGhvZCA6IFwiR0VUXCJcclxuICAgICAgICB9KS50aGVuKChyZXNwb25zZSk9PntcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIChwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpID09PSBcIkhFQURcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcclxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXHJcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcclxuICAgICAgICAgICAgICogbWFwcGVkIGxvY2F0aW9uLlxyXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDhcclxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90cnlUb1BhcnNlQXNKU09OO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF90cnlUb1BhcnNlQXNKU09OID0gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cnlUb1BhcnNlQXNKU09OLm5vdEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcclxuICAgICAgICAgICAgICogY2F1c2VkIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvXHJcbiAgICAgICAgICAgICAqIGFuIGluZmluaXRlIGxvb3AuXHJcbiAgICAgICAgICAgICAqLyBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHBhcnNlSlNPTiA/IHRyeVRvUGFyc2VBc0pTT04odGV4dCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLnRoZW4oKGRhdGEpPT57XHJcbiAgICAgICAgICAgIGlmICghcGVyc2lzdENhY2hlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLWNhY2hlXCIpID09PSBcIm5vLWNhY2hlXCIpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xyXG4gICAgICAgICAgICBpZiAoIXVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgvLyBjaHJvbWVcclxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgLy8gZmlyZWZveFxyXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiIHx8IC8vIHNhZmFyaVxyXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJMb2FkIGZhaWxlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyB3aGVuIHNraXBwaW5nIGNsaWVudCBjYWNoZSB3ZSB3YWl0IHRvIHVwZGF0ZVxyXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXHJcbiAgICAvLyB0aGlzIGFsbG93cyByYWNpbmcgY2xpY2sgZXZlbnQgd2l0aCBmZXRjaGluZyBuZXdlciBkYXRhXHJcbiAgICAvLyB3aXRob3V0IGJsb2NraW5nIG5hdmlnYXRpb24gd2hlbiBzdGFsZSBkYXRhIGlzIGF2YWlsYWJsZVxyXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGF0YSh7fSkudGhlbigoZGF0YSk9PntcclxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcclxuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiXHJcbiAgICB9IDoge30pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcclxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMCk7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlSGFyZE5hdmlnYXRpb24ocGFyYW0pIHtcclxuICAgIGxldCB7IHVybCAsIHJvdXRlciAgfSA9IHBhcmFtO1xyXG4gICAgLy8gZW5zdXJlIHdlIGRvbid0IHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIHNhbWVcclxuICAgIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXHJcbiAgICBpZiAodXJsID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHJvdXRlci5hc1BhdGgsIHJvdXRlci5sb2NhbGUpKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFyaWFudDogYXR0ZW1wdGVkIHRvIGhhcmQgbmF2aWdhdGUgdG8gdGhlIHNhbWUgVVJMIFwiICsgdXJsICsgXCIgXCIgKyBsb2NhdGlvbi5ocmVmKTtcclxuICAgIH1cclxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xyXG59XHJcbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAocGFyYW0pPT57XHJcbiAgICBsZXQgeyByb3V0ZSAsIHJvdXRlciAgfSA9IHBhcmFtO1xyXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XHJcbiAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xyXG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0Fib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJyArIHJvdXRlICsgJ1wiJyk7XHJcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XHJcbiAgICAgICAgICAgIHJvdXRlci5jbGMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gaGFuZGxlQ2FuY2VsbGVkO1xyXG59O1xyXG5jbGFzcyBSb3V0ZXIge1xyXG4gICAgcmVsb2FkKCkge1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxyXG4gICAqLyBiYWNrKCkge1xyXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIEdvIGZvcndhcmQgaW4gaGlzdG9yeVxyXG4gICAqLyBmb3J3YXJkKCkge1xyXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcclxuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxyXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXHJcbiAgICovIHB1c2godXJsLCBhcywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSB3aGVuIHdlIHVwZGF0ZSBoaXN0b3J5IGJlZm9yZSByb3V0ZSBjaGFuZ2VcclxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cclxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJwdXNoU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXHJcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcclxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xyXG4gICAqLyByZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XHJcbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGFzeW5jIF9iZmwoYXMsIHJlc29sdmVkQXMsIGxvY2FsZSwgc2tpcE5hdmlnYXRlKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsRHluYW1pYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1ckFzIG9mIFtcclxuICAgICAgICAgICAgICAgIGFzLFxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBc1xyXG4gICAgICAgICAgICBdKXtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJBcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKGN1ckFzLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzTm9TbGFzaCwgbG9jYWxlIHx8IHRoaXMubG9jYWxlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzTm9TbGFzaCAhPT0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwodGhpcy5hc1BhdGgsIFwiaHR0cDovL25cIikucGF0aG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fYmZsX3MsIF90aGlzX19iZmxfczE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChfdGhpc19fYmZsX3MgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfcy5jb250YWlucyhhc05vU2xhc2gpKSB8fCAhISgoX3RoaXNfX2JmbF9zMSA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zMS5jb250YWlucyhhc05vU2xhc2hMb2NhbGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkQVMgb2YgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoTG9jYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW55IHN1Yi1wYXRoIG9mIGFzIG1hdGNoZXMgYSBkeW5hbWljIGZpbHRlciBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckFzUGFydHMgPSBub3JtYWxpemVkQVMuc3BsaXQoXCIvXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgIW1hdGNoZXNCZmxEeW5hbWljICYmIGkgPCBjdXJBc1BhcnRzLmxlbmd0aCArIDE7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFydCA9IGN1ckFzUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0ICYmICgoX3RoaXNfX2JmbF9kID0gdGhpcy5fYmZsX2QpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX2QuY29udGFpbnMoY3VycmVudFBhcnQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsRHluYW1pYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IHJvdXRlciBmaWx0ZXIgaXMgbWF0Y2hlZCB0aGVuIHdlIHRyaWdnZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBoYXJkIG5hdmlnYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNCZmxTdGF0aWMgfHwgbWF0Y2hlc0JmbER5bmFtaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwTmF2aWdhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFzeW5jIGNoYW5nZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMsIGZvcmNlZFNjcm9sbCkge1xyXG4gICAgICAgIHZhciBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lO1xyXG4gICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybCkpIHtcclxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgdXJsLFxyXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcclxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XHJcbiAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXHJcbiAgICAgICAgY29uc3QgaXNRdWVyeVVwZGF0aW5nID0gb3B0aW9ucy5faCA9PT0gMTtcclxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgdW5kZWZpbmVkLCBvcHRpb25zLmxvY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXMpLnBhdGhuYW1lO1xyXG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5zdGF0ZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XHJcbiAgICAgICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXHJcbiAgICAgICAgLy8gb3IgYSBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZFxyXG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDaGFuZ2UgPSB0aGlzLmlzUmVhZHkgIT09IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBpc1NzciA9IHRoaXMuaXNTc3I7XHJcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1NzciA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBhIHJvdXRlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBiZWZvcmVcclxuICAgICAgICAvLyB0aGUgcXVlcnkgdXBkYXRpbmcgaXMgdHJpZ2dlcmVkIGlnbm9yZSBxdWVyeSB1cGRhdGluZ1xyXG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5jbGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xyXG4gICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlID8gdGhpcy5kZWZhdWx0TG9jYWxlIDogb3B0aW9ucy5sb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzKTtcclxuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcclxuICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRBcy5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyk7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkodXJsKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHVybCkgOiB1cmwsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcclxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbG9jYWxlcztcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcclxuICAgICAgICAgICAgICAgIGlmICghKChfdGhpc19sb2NhbGVzID0gdGhpcy5sb2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfbG9jYWxlcy5pbmNsdWRlcyhuZXh0U3RhdGUubG9jYWxlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gKDAsIF9kZXRlY3Rkb21haW5sb2NhbGUuZGV0ZWN0RG9tYWluTG9jYWxlKSh0aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxyXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkaWROYXZpZ2F0ZSAmJiBkZXRlY3RlZERvbWFpbiAmJiB0aGlzLmlzTG9jYWxlRG9tYWluICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJodHRwXCIgKyAoZGV0ZWN0ZWREb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiICsgZGV0ZWN0ZWREb21haW4uZG9tYWluICsgKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoXCJcIiArIChuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgbmV4dFN0YXRlLmxvY2FsZSkgKyAoYXNOb0Jhc2VQYXRoID09PSBcIi9cIiA/IFwiXCIgOiBhc05vQmFzZVBhdGgpIHx8IFwiL1wiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxyXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcclxuICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJyb3V0ZUNoYW5nZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBzaGFsbG93ID1mYWxzZSAsIHNjcm9sbCA9dHJ1ZSAgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcclxuICAgICAgICAgICAgc2hhbGxvd1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUgJiYgdGhpcy5jbGMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1Nzcikge1xyXG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2xjKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBvcHRpb25zLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSk7XHJcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgbmV4dFN0YXRlLmxvY2FsZSk7XHJcbiAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGU7XHJcbiAgICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcclxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXHJcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIG5leHRTdGF0ZS5hc1BhdGggPSBjbGVhbmVkQXM7XHJcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCB7XHJcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQobmV4dFN0YXRlLCB0aGlzLmNvbXBvbmVudHNbbmV4dFN0YXRlLnJvdXRlXSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJoYXNoQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xyXG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XHJcbiAgICAgICAgLy8gaWYgd2UgZGV0ZWN0ZWQgdGhlIHBhdGggYXMgYXBwIHJvdXRlIGR1cmluZyBwcmVmZXRjaGluZ1xyXG4gICAgICAgIC8vIHRyaWdnZXIgaGFyZCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgaWYgKChfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lID0gdGhpcy5jb21wb25lbnRzW3BhdGhuYW1lXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUuX19hcHBSb3V0ZXIpIHtcclxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcclxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcclxuICAgICAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcclxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xyXG4gICAgICAgIGxldCBwYWdlcywgcmV3cml0ZXM7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxyXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XHJcbiAgICAgICAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcclxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcclxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxyXG4gICAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxyXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcclxuICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxyXG4gICAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcclxuICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCA9IFwicmVwbGFjZVN0YXRlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXHJcbiAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxyXG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXM7XHJcbiAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xyXG4gICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcclxuICAgICAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxyXG4gICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUgPyAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xyXG4gICAgICAgIGxldCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkQXNQYXRobmFtZSA9IGFzLnN0YXJ0c1dpdGgoXCIvXCIpICYmICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhcykucGF0aG5hbWU7XHJcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKHBhcnNlZEFzUGF0aG5hbWUgJiYgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiYgKCEoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpIHx8ICEoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKSk7XHJcbiAgICAgICAgLy8gd2UgZG9uJ3QgYXR0ZW1wdCByZXNvbHZlIGFzUGF0aCB3aGVuIHdlIG5lZWQgdG8gZXhlY3V0ZVxyXG4gICAgICAgIC8vIG1pZGRsZXdhcmUgYXMgdGhlIHJlc29sdmluZyB3aWxsIG9jY3VyIHNlcnZlci1zaWRlXHJcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSAhb3B0aW9ucy5zaGFsbG93ICYmIGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKHtcclxuICAgICAgICAgICAgYXNQYXRoOiBhcyxcclxuICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxyXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgIHNob3VsZFJlc29sdmVIcmVmID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKFwiL1wiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcclxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShhcykpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhyZWY6IFwiJyArIHVybCArICdcIiBhbmQgYXM6IFwiJyArIGFzICsgJ1wiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhcycgKyBcIlxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgIHVybDogYXMsXHJcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xyXG4gICAgICAgIHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcclxuICAgICAgICBsZXQgcm91dGVNYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJlc29sdmVkQXMpO1xyXG4gICAgICAgICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpO1xyXG4gICAgICAgICAgICByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/ICgwLCBfaW50ZXJwb2xhdGVhcy5pbnRlcnBvbGF0ZUFzKShyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge307XHJcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcigocGFyYW0pPT4hcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCAmJiAhaXNNaWRkbGV3YXJlTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlwiICsgKHNob3VsZEludGVycG9sYXRlID8gXCJJbnRlcnBvbGF0aW5nIGhyZWZcIiA6IFwiTWlzbWF0Y2hpbmcgYGFzYCBhbmQgYGhyZWZgXCIpICsgXCIgZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgXCIgKyAoXCJ0aGUgcGFyYW1zOiBcIiArIG1pc3NpbmdQYXJhbXMuam9pbihcIiwgXCIpICsgXCIgaW4gdGhlIGBocmVmYCdzIGBxdWVyeWBcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHNob3VsZEludGVycG9sYXRlID8gXCJUaGUgcHJvdmlkZWQgYGhyZWZgIChcIiArIHVybCArIFwiKSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiKSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIFwiIDogXCJUaGUgcHJvdmlkZWQgYGFzYCB2YWx1ZSAoXCIgKyBhc1BhdGhuYW1lICsgXCIpIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBgaHJlZmAgdmFsdWUgKFwiICsgcm91dGUgKyBcIikuIFwiKSArIChcIlJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcImhyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWRcIiA6IFwiaW5jb21wYXRpYmxlLWhyZWYtYXNcIikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoMCwgX29taXQub21pdCkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcylcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xyXG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZVN0YXJ0XCIsIGFzLCByb3V0ZVByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNFcnJvclJvdXRlID0gdGhpcy5wYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgdGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLCBfcm91dGVJbmZvX3Byb3BzO1xyXG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xyXG4gICAgICAgICAgICAgICAgcm91dGUsXHJcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgYXMsXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxyXG4gICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcclxuICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcclxuICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcclxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxyXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcclxuICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIFwicmVzb2x2ZWRBc1wiIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXCJyb3V0ZVwiIGluIHJvdXRlSW5mbyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGU7XHJcbiAgICAgICAgICAgICAgICByb3V0ZSA9IHBhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyb3V0ZVByb3BzLnNoYWxsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhcnNlZC5wYXRobmFtZSkgOiBwYXJzZWQucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocm91dGVNYXRjaCkuZm9yRWFjaCgoa2V5KT0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBxdWVyeVtrZXldID09PSByb3V0ZU1hdGNoW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkQXMgPSAhcm91dGVQcm9wcy5zaGFsbG93ICYmIHJvdXRlSW5mby5yZXNvbHZlZEFzID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKG5ldyBVUkwoYXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJld3JpdGVBcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmV3cml0ZUFzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHJld3JpdGVBcywgdGhpcy5sb2NhbGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSBsb2NhbGVSZXN1bHQucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGF0aG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKHJvdXRlUmVnZXgpKG5ldyBVUkwocmV3cml0ZUFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clJvdXRlTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSByb3V0ZUluZm8gYnJpbmdzIGEgcmVkaXJlY3Qgd2Ugc2ltcGx5IGFwcGx5IGl0LlxyXG4gICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIHJvdXRlSW5mby5uZXdVcmwsIHJvdXRlSW5mby5uZXdBcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByb3V0ZUluZm8uZGVzdGluYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlSW5mby5Db21wb25lbnQ7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9zY3JpcHQuaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCkoc2NyaXB0LnByb3BzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxyXG4gICAgICAgICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkZXN0aW5hdGlvbiBmcm9tIHJlZGlyZWN0IHdpdGhvdXQgYWRkaW5nIGxvY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKFwiL1wiKSAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWRIcmVmLnBhdGhuYW1lLCBwYWdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBkZXN0aW5hdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVc7XHJcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XHJcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFwiLzQwNFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9IFwiLzQwNFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9IFwiL19lcnJvclwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlOiBub3RGb3VuZFJvdXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyA9IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMgPSByb3V0ZUluZm8ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGVJbmZvX3Byb3BzLnBhZ2VQcm9wcykpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfcm91dGVJbmZvX3JvdXRlO1xyXG4gICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTaGFsbG93Um91dGUgPSBvcHRpb25zLnNoYWxsb3cgJiYgbmV4dFN0YXRlLnJvdXRlID09PSAoKF9yb3V0ZUluZm9fcm91dGUgPSByb3V0ZUluZm8ucm91dGUpICE9IG51bGwgPyBfcm91dGVJbmZvX3JvdXRlIDogcm91dGUpO1xyXG4gICAgICAgICAgICB2YXIgX29wdGlvbnNfc2Nyb2xsO1xyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAoX29wdGlvbnNfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfb3B0aW9uc19zY3JvbGwgOiAhaXNRdWVyeVVwZGF0aW5nICYmICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xyXG4gICAgICAgICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwXHJcbiAgICAgICAgICAgIH0gOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1Njcm9sbFN0YXRlID0gZm9yY2VkU2Nyb2xsICE9IG51bGwgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbDtcclxuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGF0ZSB0aGF0IHRoZSByb3V0ZXIgZ29ubmEgc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nUm91dGVyU3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi5uZXh0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICByb3V0ZSxcclxuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxyXG4gICAgICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGNsZWFuZWRBcyxcclxuICAgICAgICAgICAgICAgIGlzRmFsbGJhY2s6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXHJcbiAgICAgICAgICAgIC8vIHF1ZXJ5IHBhcmFtZXRlcnMuIFJvdXRlIGNoYW5nZXMgaGVyZSBtaWdodCBhZGQgdGhlIGJhc2VQYXRoIHdoZW4gaXRcclxuICAgICAgICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcclxuICAgICAgICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xyXG4gICAgICAgICAgICAvLyB0aGUgVVJMKS5cclxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSwgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLCBfcm91dGVJbmZvX3Byb3BzMTtcclxuICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5wYXRobmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogdGhpcy5wYXRobmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgICAgICAgICBhcyxcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlUHJvcHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiBcIiArIHRoaXMucGF0aG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzMSA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMxLnBhZ2VQcm9wcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImJlZm9yZUhpc3RvcnlDaGFuZ2VcIiwgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIGZvciBxdWVyeSB1cGRhdGVzIHdlIGNhbiBza2lwIGl0IGlmIHRoZSBzdGF0ZSBpcyB1bmNoYW5nZWQgYW5kIHdlIGRvbid0XHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzcxMzlcclxuICAgICAgICAgICAgY29uc3QgY2FuU2tpcFVwZGF0aW5nID0gaXNRdWVyeVVwZGF0aW5nICYmICF1cGNvbWluZ1Njcm9sbFN0YXRlICYmICFyZWFkeVN0YXRlQ2hhbmdlICYmICFsb2NhbGVDaGFuZ2UgJiYgKDAsIF9jb21wYXJlc3RhdGVzLmNvbXBhcmVSb3V0ZXJTdGF0ZXMpKHVwY29taW5nUm91dGVyU3RhdGUsIHRoaXMuc3RhdGUpO1xyXG4gICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgcm91dGVJbmZvLmVycm9yLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyByb3V0ZUluZm8uZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUubG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC87XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsICYmIGhhc2hSZWdleC50ZXN0KGFzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LlwiICsgbWV0aG9kICsgXCIgaXMgbm90IGF2YWlsYWJsZVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcInB1c2hTdGF0ZVwiIHx8ICgwLCBfdXRpbHMuZ2V0VVJMKSgpICE9PSBhcykge1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xyXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcclxuICAgICAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgICAgIGFzLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIF9fTjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5fa2V5ID0gbWV0aG9kICE9PSBcInB1c2hTdGF0ZVwiID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KClcclxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXHJcbiAgICAgICAgICAgIFwiXCIsIGFzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKDAsIF9yb3V0ZWxvYWRlci5pc0Fzc2V0RXJyb3IpKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xyXG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xyXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xyXG4gICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcclxuICAgICAgICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcclxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXHJcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcclxuICAgICAgICAgICAgICAgIHVybDogYXMsXHJcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxyXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxyXG4gICAgICAgICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBwcm9wcztcclxuICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvX2Vycm9yXCIpO1xyXG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcyxcclxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxyXG4gICAgICAgICAgICAgICAgZXJyLFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiBcIiwgZ2lwRXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xyXG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzZXJyb3IuZGVmYXVsdCkocm91dGVJbmZvRXJyKSA/IHJvdXRlSW5mb0VyciA6IG5ldyBFcnJvcihyb3V0ZUluZm9FcnIgKyBcIlwiKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHBhcmFtKSB7XHJcbiAgICAgICAgbGV0IHsgcm91dGU6IHJlcXVlc3RlZFJvdXRlICwgcGF0aG5hbWUgLCBxdWVyeSAsIGFzICwgcmVzb2x2ZWRBcyAsIHJvdXRlUHJvcHMgLCBsb2NhbGUgLCBoYXNNaWRkbGV3YXJlICwgaXNQcmV2aWV3ICwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlICwgaXNRdWVyeVVwZGF0aW5nICwgaXNNaWRkbGV3YXJlUmV3cml0ZSAsIGlzTm90Rm91bmQgIH0gPSBwYXJhbTtcclxuICAgICAgICAvKipcclxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcclxuICAgICAqIHNvIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHJlcXVlc3RlZCByb3V0ZVxyXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxyXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cclxuICAgICAqLyBsZXQgcm91dGUgPSByZXF1ZXN0ZWRSb3V0ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgX2RhdGFfZWZmZWN0LCBfZGF0YV9lZmZlY3QxLCBfZGF0YV9lZmZlY3QyLCBfZGF0YV9yZXNwb25zZTtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XHJcbiAgICAgICAgICAgICAgICByb3V0ZSxcclxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XHJcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ0luZm8gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKFwiaW5pdGlhbFwiIGluIGV4aXN0aW5nSW5mbykgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwiZGV2ZWxvcG1lbnRcIiA/IGV4aXN0aW5nSW5mbyA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3QgaXNCYWNrZ3JvdW5kID0gaXNRdWVyeVVwZGF0aW5nO1xyXG4gICAgICAgICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XHJcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gXCIvNDA0XCIgOiByZXNvbHZlZEFzLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRoaXMuaXNTc3IsXHJcbiAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxyXG4gICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxyXG4gICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXHJcbiAgICAgICAgICAgICAgICBpc0JhY2tncm91bmRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGUgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcclxuICAgICAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoZmV0Y2hOZXh0RGF0YVBhcmFtcyksXHJcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyBcIi80MDRcIiA6IHJlc29sdmVkQXMsXHJcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcclxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcclxuICAgICAgICAgICAgICAgIC8vIGFzIGl0J3MgdW4tbmVjZXNzYXJ5IGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgZmF0YWxcclxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIGZhbGxiYWNrIHJvdXRlIGFuZCB0aGUgcHJvcHMgY2FuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcclxuICAgICAgICAgICAgLy8gZWZmZWN0c1xyXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09IFwiL19lcnJvclwiIHx8IHBhdGhuYW1lID09PSBcIi80MDRcIikpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuZWZmZWN0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcclxuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIiB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDEgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDEudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZWZmZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDIgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDIudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtdHJhbnNpdGlvbiBhIHJlZGlyZWN0IHRoYXQgZG9lc24ndCBtYXRjaCBhIHBhZ2VcclxuICAgICAgICAgICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgfHwgcGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRSb3V0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHJlc29sdmVkUm91dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0luZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlICYmICFoYXNNaWRkbGV3YXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gY29weSB0aGUgZXhpc3RpbmcgaW5mb3JtYXRpb24gdG8gdGhlIHJld3JpdHRlbiBvbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWxvbmcgd2l0aCB0aGUgbWF0Y2hlZCByb3V0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nSW5mbyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoMCwgX2lzYXBpcm91dGUuaXNBUElSb3V0ZSkocm91dGUpKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxyXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcclxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1BcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocm91dGVJbmZvLkNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCInICsgcGF0aG5hbWUgKyAnXCInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB3YXNCYWlsZWRQcmVmZXRjaCA9IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9yZXNwb25zZSA9IGRhdGEucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9yZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWlkZGxld2FyZS1za2lwXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcclxuICAgICAgICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXHJcbiAgICAgICAgICAgIC8vIHdlIGNsZWFyIHRoZSBjYWNoZSB0byBmZXRjaCBmdWxsIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tkYXRhLmRhdGFIcmVmXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzICwgY2FjaGVLZXkgIH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKGFzeW5jICgpPT57XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRmV0Y2hEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZGF0YS5qc29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpID8gZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWQgPSBhd2FpdCBmZXRjaE5leHREYXRhKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBmZXRjaGVkLmpzb24gfHwge31cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wczogYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMocm91dGVJbmZvLkNvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gT25seSBidXN0IHRoZSBkYXRhIGNhY2hlIGZvciBTU1Agcm91dGVzIGFsdGhvdWdoXHJcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxyXG4gICAgICAgICAgICAvLyB4LW1pZGRsZXdhcmUtY2FjaGU6IG5vLWNhY2hlIGFzIHdlbGxcclxuICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5fX05fU1NQICYmIGZldGNoTmV4dERhdGFQYXJhbXMuZGF0YUhyZWYgJiYgY2FjaGVLZXkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tjYWNoZUtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2Uga2ljayBvZmYgYSBIRUFEIHJlcXVlc3QgaW4gdGhlIGJhY2tncm91bmRcclxuICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3ICYmIHJvdXRlSW5mby5fX05fU1NHICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgJiYgIWlzUXVlcnlVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgZmV0Y2hOZXh0RGF0YShPYmplY3QuYXNzaWduKHt9LCBmZXRjaE5leHREYXRhUGFyYW1zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zYmNcclxuICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoKT0+e30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BzLnBhZ2VQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBhZ2VQcm9wcyk7XHJcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xyXG4gICAgICAgICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZTtcclxuICAgICAgICAgICAgcm91dGVJbmZvLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBcztcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXQoc3RhdGUsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcclxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcclxuICAgKi8gYmVmb3JlUG9wU3RhdGUoY2IpIHtcclxuICAgICAgICB0aGlzLl9icHMgPSBjYjtcclxuICAgIH1cclxuICAgIG9ubHlBSGFzaENoYW5nZShhcykge1xyXG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KFwiI1wiKTtcclxuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KFwiI1wiKTtcclxuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxyXG4gICAgICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxyXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcclxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxyXG4gICAgICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXHJcbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XHJcbiAgICB9XHJcbiAgICBzY3JvbGxUb0hhc2goYXMpIHtcclxuICAgICAgICBjb25zdCBbLCBoYXNoID0gXCJcIl0gPSBhcy5zcGxpdChcIiNcIik7XHJcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxyXG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xyXG4gICAgICAgIGlmIChoYXNoID09PSBcIlwiIHx8IGhhc2ggPT09IFwidG9wXCIpIHtcclxuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+d2luZG93LnNjcm9sbFRvKDAsIDApKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXHJcbiAgICAgICAgY29uc3QgcmF3SGFzaCA9IGRlY29kZVVSSUNvbXBvbmVudChoYXNoKTtcclxuICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxyXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKTtcclxuICAgICAgICBpZiAoaWRFbCkge1xyXG4gICAgICAgICAgICAoMCwgX2hhbmRsZXNtb290aHNjcm9sbC5oYW5kbGVTbW9vdGhTY3JvbGwpKCgpPT5pZEVsLnNjcm9sbEludG9WaWV3KCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxyXG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xyXG4gICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHJhd0hhc2gpWzBdO1xyXG4gICAgICAgIGlmIChuYW1lRWwpIHtcclxuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+bmFtZUVsLnNjcm9sbEludG9WaWV3KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVybElzTmV3KGFzUGF0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cclxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxyXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXHJcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXHJcbiAgICovIGFzeW5jIHByZWZldGNoKHVybCwgYXNQYXRoLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGFzUGF0aCA9PT0gdm9pZCAwKSBhc1BhdGggPSB1cmw7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgKDAsIF9pc2JvdC5pc0JvdCkod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHByZWZldGNoZXMgZm9yIGJvdHMgdGhhdCByZW5kZXIgdGhlIGxpbmsgc2luY2UgdGhleSBhcmUgdHlwaWNhbGx5IG5hdmlnYXRpbmdcclxuICAgICAgICAgICAgLy8gbGlua3MgdmlhIHRoZSBlcXVpdmFsZW50IG9mIGEgaGFyZCBuYXZpZ2F0aW9uIGFuZCBoZW5jZSBuZXZlciB1dGlsaXplIHRoZXNlXHJcbiAgICAgICAgICAgIC8vIHByZWZldGNoZXMuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xyXG4gICAgICAgIGNvbnN0IHVybFBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xyXG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcclxuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhc1BhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcclxuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGU7XHJcbiAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XHJcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XHJcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkIDogdGhpcy5sb2NhbGU7XHJcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XHJcbiAgICAgICAgICAgIGFzUGF0aDogYXNQYXRoLFxyXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcclxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XHJcbiAgICAgICAgICAgIGxldCByZXdyaXRlcztcclxuICAgICAgICAgICAgKHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH0gPSBhd2FpdCAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCkpO1xyXG4gICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKCgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXNQYXRoLCB0aGlzLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgdGhpcy5sb2NhbGVzKTtcclxuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIHRoaXMubG9jYWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xyXG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFyc2VkLnBhdGhuYW1lKSkge1xyXG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcclxuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhcnNlZC5wYXRobmFtZSkpKCgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXNQYXRoKS5wYXRobmFtZSkgfHwge30pO1xyXG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09IFwic3RyaWN0XCIgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcclxuICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogb3JpZ2luYWxQYXRobmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcclxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcclxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXHJcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxyXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAqIElmIHRoZXJlIHdhcyBhIHJld3JpdGUgd2UgYXBwbHkgdGhlIGVmZmVjdHMgb2YgdGhlIHJld3JpdGUgb24gdGhlXHJcbiAgICAgKiBjdXJyZW50IHBhcmFtZXRlcnMgZm9yIHRoZSBwcmVmZXRjaC5cclxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJld3JpdGVcIikge1xyXG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XHJcbiAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xyXG4gICAgICAgICAgICBxdWVyeSA9IHtcclxuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgKiBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IHRvIGFuIGV4dGVybmFsIGRlc3RpbmF0aW9uIHRoZW4gd2UgZG9uJ3QgaGF2ZVxyXG4gICAgICogdG8gcHJlZmV0Y2ggY29udGVudCBhcyBpdCB3aWxsIGJlIHVudXNlZC5cclxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XHJcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuX2JmbChhc1BhdGgsIHJlc29sdmVkQXMsIG9wdGlvbnMubG9jYWxlLCB0cnVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdXJsUGF0aG5hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgX19hcHBSb3V0ZXI6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZyk9PntcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5qc29uKSA/IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYgOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGVcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB8fCBvcHRpb25zLnByaW9yaXR5ICYmICEhcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT5mYWxzZSkuY2F0Y2goKCk9PmZhbHNlKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyBcImxvYWRQYWdlXCIgOiBcInByZWZldGNoXCJdKHJvdXRlKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcclxuICAgICAgICAgICAgcm91dGUsXHJcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XHJcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXREYXRhKGZuKSB7XHJcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XHJcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNsYyA9IGNhbmNlbDtcclxuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xyXG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIkxvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWRcIik7XHJcbiAgICAgICAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKSB7XHJcbiAgICAgICAgLy8gRG8gbm90IGNhY2hlIFJTQyBmbGlnaHQgcmVzcG9uc2Ugc2luY2UgaXQncyBub3QgYSBzdGF0aWMgcmVzb3VyY2VcclxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YSh7XHJcbiAgICAgICAgICAgIGRhdGFIcmVmLFxyXG4gICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcGFyc2VKU09OOiBmYWxzZSxcclxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXHJcbiAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlXHJcbiAgICAgICAgfSkudGhlbigocGFyYW0pPT57XHJcbiAgICAgICAgICAgIGxldCB7IHRleHQgIH0gPSBwYXJhbTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IHRleHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xyXG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgIH0gPSB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXTtcclxuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xyXG4gICAgICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZTtcclxuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsIHtcclxuICAgICAgICAgICAgQXBwVHJlZSxcclxuICAgICAgICAgICAgQ29tcG9uZW50LFxyXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXHJcbiAgICAgICAgICAgIGN0eFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJvdXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhdGhuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGhuYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IHF1ZXJ5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXJ5O1xyXG4gICAgfVxyXG4gICAgZ2V0IGFzUGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5hc1BhdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9jYWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmxvY2FsZTtcclxuICAgIH1cclxuICAgIGdldCBpc0ZhbGxiYWNrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRmFsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNQcmV2aWV3KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzUHJldmlldztcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lLCBxdWVyeSwgYXMsIHsgaW5pdGlhbFByb3BzICwgcGFnZUxvYWRlciAsIEFwcCAsIHdyYXBBcHAgLCBDb21wb25lbnQgLCBlcnIgLCBzdWJzY3JpcHRpb24gLCBpc0ZhbGxiYWNrICwgbG9jYWxlICwgbG9jYWxlcyAsIGRlZmF1bHRMb2NhbGUgLCBkb21haW5Mb2NhbGVzICwgaXNQcmV2aWV3ICB9KXtcclxuICAgICAgICAvLyBTZXJ2ZXIgRGF0YSBDYWNoZSAoZnVsbCBkYXRhIHJlcXVlc3RzKVxyXG4gICAgICAgIHRoaXMuc2RjID0ge307XHJcbiAgICAgICAgLy8gU2VydmVyIEJhY2tncm91bmQgQ2FjaGUgKEhFQUQgcmVxdWVzdHMpXHJcbiAgICAgICAgdGhpcy5zYmMgPSB7fTtcclxuICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBjcmVhdGVLZXkoKTtcclxuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcclxuICAgICAgICAgICAgY29uc3QgeyBpc0ZpcnN0UG9wU3RhdGVFdmVudCAgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cclxuICAgICAgICAgICAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxyXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXHJcbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cclxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscy5nZXRVUkwpKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cclxuICAgICAgICAgICAgaWYgKHN0YXRlLl9fTkEpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxyXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiYgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXMgLCBvcHRpb25zICwga2V5ICB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcIl9fbmV4dF9zY3JvbGxfXCIgKyBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXHJcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5hc1BhdGgpICYmIHBhdGhuYW1lID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLnBhdGhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cclxuICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKFwicmVwbGFjZVN0YXRlXCIsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxyXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXHJcbiAgICAgICAgICAgICAgICBfaDogMFxyXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxyXG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcclxuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcclxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcclxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcclxuICAgICAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXHJcbiAgICAgICAgaWYgKHBhdGhuYW1lICE9PSBcIi9fZXJyb3JcIikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0ge1xyXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXHJcbiAgICAgICAgICAgICAgICBlcnIsXHJcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXHJcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1BcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl0gPSB7XHJcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxyXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IEJsb29tRmlsdGVyICB9ID0gcmVxdWlyZShcIi4uLy4uL2xpYi9ibG9vbS1maWx0ZXJcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXRpY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUjtcclxuICAgICAgICAgICAgY29uc3QgZHluYW1pY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUjtcclxuICAgICAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0ZpbHRlckRhdGEubnVtSGFzaGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcyA9IG5ldyBCbG9vbUZpbHRlcihzdGF0aWNGaWx0ZXJEYXRhLm51bUl0ZW1zLCBzdGF0aWNGaWx0ZXJEYXRhLmVycm9yUmF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcy5pbXBvcnQoc3RhdGljRmlsdGVyRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBkeW5hbWljRmlsdGVyRGF0YS5udW1IYXNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kID0gbmV3IEJsb29tRmlsdGVyKGR5bmFtaWNGaWx0ZXJEYXRhLm51bUl0ZW1zLCBkeW5hbWljRmlsdGVyRGF0YS5lcnJvclJhdGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QuaW1wb3J0KGR5bmFtaWNGaWx0ZXJEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xyXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xyXG4gICAgICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XHJcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcclxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxyXG4gICAgICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID0gKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydDtcclxuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xyXG4gICAgICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcclxuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXHJcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcclxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXM7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhISgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHJvdXRlLFxyXG4gICAgICAgICAgICBwYXRobmFtZSxcclxuICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgIGFzUGF0aDogYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzLFxyXG4gICAgICAgICAgICBpc1ByZXZpZXc6ICEhaXNQcmV2aWV3LFxyXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXHJcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXHJcbiAgICAgICAgICAgIGlmICghYXMuc3RhcnRzV2l0aChcIi8vXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aCA9ICgwLCBfdXRpbHMuZ2V0VVJMKSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IG1hdGNoZXNNaWRkbGV3YXJlKHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aFxyXG4gICAgICAgICAgICAgICAgfSkudGhlbigobWF0Y2hlcyk9PntcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFwicmVwbGFjZVN0YXRlXCIsIG1hdGNoZXMgPyBhc1BhdGggOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCBhc1BhdGgsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xyXG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4oKCk9PntcclxuICAgIFJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQuZGVmYXVsdCkoKTtcclxufSkoKTtcclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJkZWZhdWx0IiwibWF0Y2hlc01pZGRsZXdhcmUiLCJjcmVhdGVLZXkiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJSb3V0ZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZW1vdmV0cmFpbGluZ3NsYXNoIiwiX3JvdXRlbG9hZGVyIiwiX3NjcmlwdCIsIl9pc2Vycm9yIiwiXyIsIl9kZW5vcm1hbGl6ZXBhZ2VwYXRoIiwiX25vcm1hbGl6ZWxvY2FsZXBhdGgiLCJfbWl0dCIsIl91dGlscyIsIl9pc2R5bmFtaWMiLCJfcGFyc2VyZWxhdGl2ZXVybCIsIl9yZXNvbHZlcmV3cml0ZXMiLCJfcm91dGVtYXRjaGVyIiwiX3JvdXRlcmVnZXgiLCJfZm9ybWF0dXJsIiwiX2RldGVjdGRvbWFpbmxvY2FsZSIsIl9wYXJzZXBhdGgiLCJfYWRkbG9jYWxlIiwiX3JlbW92ZWxvY2FsZSIsIl9yZW1vdmViYXNlcGF0aCIsIl9hZGRiYXNlcGF0aCIsIl9oYXNiYXNlcGF0aCIsIl9pc2FwaXJvdXRlIiwiX2dldG5leHRwYXRobmFtZWluZm8iLCJfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyIsIl9jb21wYXJlc3RhdGVzIiwiX2lzbG9jYWx1cmwiLCJfaXNib3QiLCJfb21pdCIsIl9yZXNvbHZlaHJlZiIsIl9pbnRlcnBvbGF0ZWFzIiwiX2hhbmRsZXNtb290aHNjcm9sbCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsIm9wdGlvbnMiLCJtYXRjaGVycyIsImFzUGF0aG5hbWUiLCJjbGVhbmVkQXMiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJwYXRobmFtZSIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicHJlcGFyZVVybEFzIiwiYXMiLCJyZXNvbHZlSHJlZiIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJocmVmV2FzQWJzb2x1dGUiLCJhc1dhc0Fic29sdXRlIiwicHJlcGFyZWRVcmwiLCJwcmVwYXJlZEFzIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhZ2VzIiwiY2xlYW5QYXRobmFtZSIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiaW5jbHVkZXMiLCJwYWdlIiwiaXNEeW5hbWljUm91dGUiLCJnZXRSb3V0ZVJlZ2V4IiwicmUiLCJnZXRNaWRkbGV3YXJlRGF0YSIsInNvdXJjZSIsInJlc3BvbnNlIiwibmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsImxvY2FsZXMiLCJ0cmFpbGluZ1NsYXNoIiwiQm9vbGVhbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJyZXdyaXRlSGVhZGVyIiwiaGVhZGVycyIsInJld3JpdGVUYXJnZXQiLCJtYXRjaGVkUGF0aCIsIl9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSIsInBhcnNlZFJld3JpdGVUYXJnZXQiLCJwYXJzZVJlbGF0aXZlVXJsIiwicGF0aG5hbWVJbmZvIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhcnNlRGF0YSIsImZzUGF0aG5hbWUiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwicGFyYW0iLCJfX3Jld3JpdGVzIiwicmV3cml0ZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGFyc2VkU291cmNlIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsInVuZGVmaW5lZCIsInJlc3VsdCIsInF1ZXJ5IiwicGF0aCIsIm1hdGNoZWRQYWdlIiwicGFyc2VkQXMiLCJyZXNvbHZlZFBhdGhuYW1lIiwibWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInR5cGUiLCJzcmMiLCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiZGVmYXVsdExvY2FsZSIsImJ1aWxkSWQiLCJkZXN0aW5hdGlvbiIsImhhc2giLCJyZWRpcmVjdFRhcmdldCIsIm5ld0FzIiwibmV3VXJsIiwid2l0aE1pZGRsZXdhcmVFZmZlY3RzIiwiZGF0YSIsImVmZmVjdCIsImUiLCJmZXRjaERhdGEiLCJkYXRhSHJlZiIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiVVJMIiwibG9jYXRpb24iLCJocmVmIiwiX3BhcmFtc19tZXRob2QiLCJnZXREYXRhIiwicGFyYW1zIiwicHVycG9zZSIsIl90cnlUb1BhcnNlQXNKU09OIiwibm90Rm91bmQiLCJtYXJrQXNzZXRFcnJvciIsImNhdGNoIiwiZXJyIiwibWVzc2FnZSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiaGFuZGxlSGFyZE5hdmlnYXRpb24iLCJnZXRDYW5jZWxsZWRIYW5kbGVyIiwicm91dGUiLCJjYW5jZWwiLCJjbGMiLCJoYW5kbGVDYW5jZWxsZWQiLCJpbml0aWFsUHJvcHMiLCJBcHAiLCJ3cmFwQXBwIiwiQ29tcG9uZW50Iiwic3Vic2NyaXB0aW9uIiwiaXNGYWxsYmFjayIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJzZGMiLCJzYmMiLCJpc0ZpcnN0UG9wU3RhdGVFdmVudCIsIl9rZXkiLCJvblBvcFN0YXRlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZ2V0VVJMIiwiX19OQSIsInJlbG9hZCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImtleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwibnVtSGFzaGVzIiwiX2JmbF9zIiwibnVtSXRlbXMiLCJlcnJvclJhdGUiLCJpbXBvcnQiLCJfYmZsX2QiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInN1YiIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJob3N0bmFtZSIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwiYmFjayIsImZvcndhcmQiLCJwdXNoIiwicmVwbGFjZSIsIl9iZmwiLCJza2lwTmF2aWdhdGUiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJjdXJBcyIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsIl90aGlzX19iZmxfcyIsIl90aGlzX19iZmxfczEiLCJub3JtYWxpemVkQVMiLCJjdXJBc1BhcnRzIiwiaSIsIl90aGlzX19iZmxfZCIsImN1cnJlbnRQYXJ0IiwiY29udGFpbnMiLCJzcGxpdCIsImpvaW4iLCJfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lIiwiaXNRdWVyeVVwZGF0aW5nIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwicHJldkxvY2FsZSIsImxvY2FsZVBhdGhSZXN1bHQiLCJkaWROYXZpZ2F0ZSIsIl90aGlzX2xvY2FsZXMiLCJkZXRlY3RlZERvbWFpbiIsImFzTm9CYXNlUGF0aCIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJsb2NhbGVDaGFuZ2UiLCJwYXJzZWQiLCJwYXJzZWRBc1BhdGhuYW1lIiwiaXNNaWRkbGV3YXJlUmV3cml0ZSIsImlzTWlkZGxld2FyZU1hdGNoIiwicmV3cml0ZXNSZXN1bHQiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkQXMiLCJtaXNzaW5nUGFyYW1zIiwiaXNFcnJvclJvdXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzIiwiX3JvdXRlSW5mb19wcm9wcyIsInJvdXRlSW5mbyIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsInByZWZpeGVkQXMiLCJyZXdyaXRlQXMiLCJsb2NhbGVSZXN1bHQiLCJjdXJSb3V0ZU1hdGNoIiwiY29tcG9uZW50Iiwic2NyaXB0cyIsInBhcnNlZEhyZWYiLCJub3RGb3VuZFJvdXRlIiwiX3JvdXRlSW5mb19yb3V0ZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfb3B0aW9uc19zY3JvbGwiLCJzaG91bGRTY3JvbGwiLCJyZXNldFNjcm9sbCIsInVwY29taW5nU2Nyb2xsU3RhdGUiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEiLCJfcm91dGVJbmZvX3Byb3BzMSIsImNhblNraXBVcGRhdGluZyIsImhhc2hSZWdleCIsImlzTG9jYWxVUkwiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsIl9pbkZsaWdodFJvdXRlIiwiZW1pdCIsInJlbW92ZUxvY2FsZSIsIm9ubHlBSGFzaENoYW5nZSIsInNjcm9sbFRvSGFzaCIsInNldCIsIl9fYXBwUm91dGVyIiwidXJsSXNOZXciLCJwIiwiZXh0ZXJuYWxEZXN0IiwiaW50ZXJwb2xhdGVBcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJvcHRpb25hbCIsImNvbnNvbGUiLCJ3YXJuIiwib21pdCIsImdldFJvdXRlSW5mbyIsImZvckVhY2giLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX0JBU0VfUEFUSCIsIl9fTl9QUkVWSUVXIiwiZmV0Y2hDb21wb25lbnQiLCJpc05vdEZvdW5kIiwic3RhdHVzQ29kZSIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJyZXF1ZXN0ZWRSb3V0ZSIsIl9kYXRhX2VmZmVjdCIsIl9kYXRhX2VmZmVjdDEiLCJfZGF0YV9lZmZlY3QyIiwiX2RhdGFfcmVzcG9uc2UiLCJleGlzdGluZ0luZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJmZXRjaE5leHREYXRhUGFyYW1zIiwicmVzb2x2ZWRSb3V0ZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsIndhc0JhaWxlZFByZWZldGNoIiwic2hvdWxkRmV0Y2hEYXRhIiwiZ2V0RGF0YUhyZWYiLCJza2lwSW50ZXJwb2xhdGlvbiIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJfZ2V0RGF0YSIsImZldGNoZWQiLCJnZXRQcm9wZXJFcnJvciIsImJlZm9yZVBvcFN0YXRlIiwiY2IiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJwcmVmZXRjaCIsInVybFBhdGhuYW1lIiwib3JpZ2luYWxQYXRobmFtZSIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0giLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFIiwiY29tcG9uZW50UmVzdWx0IiwibG9hZFBhZ2UiLCJmbiIsIl9nZXRGbGlnaHREYXRhIiwiY3R4IiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});